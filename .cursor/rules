# Cursor Rules for phpstan-fixer

## Test-Driven Development (TDD)

**ALWAYS follow Test-Driven Development (TDD) approach:**

1. **Write tests FIRST** - Before implementing any feature, bug fix, or refactoring:
   - Write failing tests that describe the desired behavior
   - Tests should be specific, clear, and cover edge cases
   - Use descriptive test method names that explain what is being tested

2. **Then implement** - Only after tests are written:
   - Implement the minimum code needed to make tests pass
   - Keep implementation simple and focused
   - Refactor if needed while keeping tests green

3. **Test coverage** - Ensure:
   - Unit tests for individual components
   - Integration tests for component interactions
   - Edge cases and error conditions are tested
   - All tests pass before committing

4. **Test structure** - Follow this pattern:
   ```php
   public function testDescriptionOfWhatIsBeingTested(): void
   {
       // Arrange - Set up test data and conditions
       
       // Act - Execute the code being tested
       
       // Assert - Verify the expected outcome
   }
   ```

## Design Principles & Best Practices

### SOLID Principles

**Always apply SOLID principles when designing and implementing code:**

1. **S - Single Responsibility Principle (SRP)**
   - Each class should have one reason to change
   - A class should do one thing and do it well
   - If a class has multiple responsibilities, split it into separate classes

2. **O - Open/Closed Principle (OCP)**
   - Classes should be open for extension but closed for modification
   - Use interfaces and abstract classes for extensibility
   - Prefer composition over inheritance when possible

3. **L - Liskov Substitution Principle (LSP)**
   - Derived classes must be substitutable for their base classes
   - Subtypes must be behaviorally compatible with their base types
   - Don't break contracts defined by base classes/interfaces

4. **I - Interface Segregation Principle (ISP)**
   - Clients should not be forced to depend on interfaces they don't use
   - Create small, focused interfaces rather than large, general ones
   - Prefer multiple specific interfaces over one general interface

5. **D - Dependency Inversion Principle (DIP)**
   - Depend on abstractions, not concretions
   - High-level modules should not depend on low-level modules
   - Both should depend on abstractions (interfaces)

### KISS (Keep It Simple, Stupid)

- **Prioritize simplicity** over cleverness
- Simple solutions are easier to understand, maintain, and debug
- Avoid over-engineering - solve today's problems, not tomorrow's
- If code is hard to understand, it's too complex

### DRY (Don't Repeat Yourself)

- **Eliminate code duplication**
- Extract common functionality into reusable methods/classes
- But balance DRY with practicality - don't abstract prematurely
- If duplication is accidental, refactor; if intentional, document why

### GRASP Principles (General Responsibility Assignment Software Patterns)

1. **Creator** - Assign class B the responsibility to create class A if B contains, uses, or aggregates A
2. **Information Expert** - Assign responsibility to the class that has the information needed to fulfill it
3. **Low Coupling** - Minimize dependencies between classes
4. **High Cohesion** - Keep related functionality together in the same class
5. **Controller** - Use intermediate classes to handle system events
6. **Polymorphism** - Use polymorphic behavior to handle variations
7. **Pure Fabrication** - Create artificial classes when needed to maintain cohesion and coupling
8. **Indirection** - Introduce intermediate abstractions to decouple components
9. **Protected Variations** - Design stable interfaces that protect against variations in implementation

## Code Smells & Anti-Patterns

**Recognize and avoid common code smells:**

### Bloaters
- **Long Method** - Extract methods to keep methods small (ideally < 20 lines)
- **Large Class** - Split classes that do too much
- **Primitive Obsession** - Use value objects instead of primitives
- **Long Parameter List** - Use objects or parameter objects
- **Data Clumps** - Extract related data into objects

### Object-Orientation Abusers
- **Switch Statements** - Use polymorphism instead
- **Temporary Field** - Move to a separate class
- **Refused Bequest** - Reconsider inheritance hierarchy
- **Alternative Classes with Different Interfaces** - Unify interfaces

### Change Preventers
- **Divergent Change** - Split classes changed for different reasons
- **Shotgun Surgery** - Move related changes into a single class
- **Parallel Inheritance Hierarchies** - Merge hierarchies

### Dispensables
- **Dead Code** - Remove unused code
- **Speculative Generality** - Remove unnecessary abstractions
- **Lazy Class** - Merge into other classes or remove
- **Data Class** - Add behavior to data-only classes
- **Duplicate Code** - Extract to a common location

### Couplers
- **Feature Envy** - Move method closer to the data it uses
- **Inappropriate Intimacy** - Reduce coupling between classes
- **Message Chains** - Break long chains of method calls
- **Middle Man** - Remove unnecessary delegation

## Architecture Principles

1. **Layered Architecture**
   - Separate concerns into distinct layers (presentation, business logic, data access)
   - Each layer should only depend on layers below it

2. **Dependency Injection**
   - Inject dependencies through constructors or setters
   - Avoid static dependencies and global state
   - Use interfaces for dependencies

3. **Separation of Concerns**
   - Each module/class should have a single, well-defined purpose
   - Keep business logic separate from infrastructure concerns

4. **Domain-Driven Design (DDD)**
   - Model the domain, not the database
   - Use value objects and entities appropriately
   - Keep domain logic in domain objects

## Refactoring Guidelines

**Refactor continuously, not only when code is broken:**

1. **When to Refactor:**
   - Before adding new features (make room for changes)
   - After fixing bugs (improve code quality)
   - When code smells are detected
   - During code reviews

2. **Refactoring Techniques:**
   - Extract Method - Break long methods into smaller ones
   - Extract Class - Split large classes
   - Move Method - Move methods to more appropriate classes
   - Replace Conditional with Polymorphism
   - Introduce Parameter Object
   - Replace Magic Numbers with Named Constants

3. **Refactoring Safety:**
   - Ensure comprehensive test coverage before refactoring
   - Refactor in small, incremental steps
   - Run tests after each step
   - Use IDE refactoring tools when available

## Redesign & Refactoring Strategy

1. **Assess Current State**
   - Identify pain points and bottlenecks
   - Document architectural issues
   - Measure technical debt

2. **Design New Architecture**
   - Apply SOLID, GRASP, and other principles
   - Create clear boundaries between components
   - Design for change and extensibility

3. **Incremental Migration**
   - Refactor incrementally, not in big-bang rewrites
   - Use strangler fig pattern - gradually replace old code
   - Maintain backward compatibility during migration
   - Write tests for both old and new implementations

4. **Validation**
   - Ensure all tests pass after refactoring
   - Verify behavior hasn't changed (except intended changes)
   - Measure improvements (performance, maintainability)

## Code Quality

- Follow PSR-12 coding standards
- Use strict types (`declare(strict_types=1);`)
- Add PHPDoc comments for all public methods
- Keep methods small and focused (single responsibility)
- Use meaningful variable and method names
- Prefer explicit over implicit
- Use type hints everywhere possible
- Avoid magic numbers and strings - use named constants

## PHPStan

- Maintain PHPStan level 5 or higher
- Fix all PHPStan errors before committing
- Use `@phpstan-ignore` comments sparingly and with justification

## Git Workflow

- Write clear, descriptive commit messages
- One logical change per commit
- Run pre-commit hooks (phpstan-fixer, PHPStan, PHPUnit) before committing
- Use conventional commits format when possible (feat:, fix:, refactor:, etc.)

